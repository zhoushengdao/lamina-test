use lamina_test::s;
use rstest::rstest;

#[rstest]
#[case("[pi()]", "[π]")]
#[case("[e()]", "[e]")]
#[case("[true]", "[true]")]
#[case("[false]", "[false]")]
#[case("[null]", "[null]")]
#[case(r#"["str"]"#, "[str]")] // TODO
#[case(r#"["excape\"str"]"#, r#"[excape"str]"#)] // TODO
#[case(r#"["comma,str"]"#, r#"[comma,str]"#)] //  TODO
#[case(r#"["中文支持"]"#, "[中文支持]")] // TODO
fn builtin_object(#[case] input: String, #[case] expected: String) {
    assert_eq!(expected, s(input.clone()), "简单表达式“{}”", input);
}

#[rstest]
#[case("[0]", "[0]")]
#[case("[-0]", "[0]")]
#[case("[1]", "[1]")]
#[case("[-1]", "[-1]")]
fn normal_number(#[case] input: String, #[case] expected: String) {
    assert_eq!(expected, s(input.clone()), "简单表达式“{}”", input);
}

#[rstest]
#[case("[10]", "[10]")]
#[case("[100]", "[100]")]
#[case("[1000]", "[1000]")]
#[case("[10000]", "[10000]")]
#[case("[100000]", "[100000]")]
#[case("[1000000]", "[1000000]")]
#[case("[10000000]", "[10000000]")]
#[case("[100000000]", "[100000000]")]
#[case("[1000000000]", "[1000000000]")]
#[case("[10000000000]", "[10000000000]")]
#[case("[100000000000]", "[100000000000]")]
#[case("[1000000000000]", "[1000000000000]")]
#[case("[1000000000000000]", "[1000000000000000]")]
#[case("[1000000000000000000]", "[1000000000000000000]")]
#[case("[1000000000000000000000]", "[1000000000000000000000]")]
#[case("[1000000000000000000000000]", "[1000000000000000000000000]")]
#[case("[1000000000000000000000000000]", "[1000000000000000000000000000]")]
#[case(
    "[1000000000000000000000000000000]",
    "[1000000000000000000000000000000]"
)]
fn big_number(#[case] input: String, #[case] expected: String) {
    assert_eq!(expected, s(input.clone()), "简单表达式“{}”", input);
}

#[rstest]
#[case("[0.1]", "[0.1]")]
#[case("[0.01]", "[0.01]")]
#[case("[0.001]", "[0.001]")]
#[case("[0.0001]", "[0.0001]")]
#[case("[0.00001]", "[0.00001]")]
#[case("[0.000001]", "[0.000001]")]
#[case("[0.0000001]", "[0.0000001]")]
#[case("[0.00000001]", "[0.00000001]")]
#[case("[0.000000001]", "[0.000000001]")]
#[case("[0.0000000001]", "[0.0000000001]")]
#[case("[0.00000000001]", "[0.00000000001]")]
#[case("[0.000000000001]", "[0.000000000001]")]
#[case("[0.000000000000001]", "[0.000000000000001]")]
#[case("[0.000000000000000001]", "[0.000000000000000001]")]
#[case("[0.000000000000000000001]", "[0.000000000000000000001]")]
#[case("[0.000000000000000000000001]", "[0.000000000000000000000001]")]
#[case("[0.000000000000000000000000001]", "[0.000000000000000000000000001]")]
#[case(
    "[0.000000000000000000000000000001]",
    "[0.000000000000000000000000000001]"
)]
fn small_number(#[case] input: String, #[case] expected: String) {
    assert_eq!(expected, s(input.clone()), "简单表达式“{}”", input);
}

#[rstest]
#[case("[sqrt(pi())]", "[√π]")]
#[case("[sqrt(e())]", "[√e]")]
fn sqrt_builtin_object(#[case] input: String, #[case] expected: String) {
    assert_eq!(expected, s(input.clone()), "简单表达式“{}”", input);
}

#[rstest]
#[case("[sqrt(0)]", "[0]")]
#[case("[sqrt(-0)]", "[0]")]
#[case("[sqrt(1)]", "[1]")]
fn sqrt_normal_object(#[case] input: String, #[case] expected: String) {
    assert_eq!(expected, s(input.clone()), "简单表达式“{}”", input);
}

#[rstest]
#[case("[sqrt(10)]", "[√10]")]
#[case("[sqrt(100)]", "[10]")]
#[case("[sqrt(1000)]", "[10√10]")]
#[case("[sqrt(10000)]", "[100]")]
#[case("[sqrt(100000)]", "[100√10]")]
#[case("[sqrt(1000000)]", "[1000]")]
#[case("[sqrt(10000000)]", "[1000√10]")]
#[case("[sqrt(100000000)]", "[10000]")]
#[case("[sqrt(1000000000)]", "[10000√10]")]
#[case("[sqrt(10000000000)]", "[100000]")]
#[case("[sqrt(100000000000)]", "[100000√10]")]
#[case("[sqrt(1000000000000)]", "[1000000]")]
#[case("[sqrt(1000000000000000)]", "[10000000√10]")]
#[case("[sqrt(1000000000000000000)]", "[1000000000]")]
#[case("[sqrt(1000000000000000000000)]", "[10000000000√10]")]
#[case("[sqrt(1000000000000000000000000)]", "[1000000000000]")]
#[case("[sqrt(1000000000000000000000000000)]", "[10000000000000√10]")]
#[case("[sqrt(1000000000000000000000000000000)]", "[1000000000000000]")]
fn sqrt_big_number(#[case] input: String, #[case] expected: String) {
    assert_eq!(expected, s(input.clone()), "简单表达式“{}”", input);
}

#[rstest]
#[case("[sqrt(0.1)]", "[√10/10]")] // TODO
#[case("[sqrt(0.01)]", "[1/10]")] // TODO
#[case("[sqrt(0.001)]", "[√10/100]")] // TODO
#[case("[sqrt(0.0001)]", "[1/100]")] // TODO
#[case("[sqrt(0.00001)]", "[√10/1000]")] // TODO
#[case("[sqrt(0.000001)]", "[1/1000]")] // TODO
#[case("[sqrt(0.0000001)]", "[√10/10000]")] // TODO
#[case("[sqrt(0.00000001)]", "[1/10000]")] // TODO
#[case("[sqrt(0.000000001)]", "[√10/100000]")] // TODO
#[case("[sqrt(0.0000000001)]", "[1/100000]")] // TODO
#[case("[sqrt(0.00000000001)]", "[√10/1000000]")] // TODO
#[case("[sqrt(0.000000000001)]", "[1/1000000]")] // TODO
#[case("[sqrt(0.000000000000001)]", "[√10/100000000]")] // TODO
#[case("[sqrt(0.000000000000000001)]", "[1/1000000000]")] // TODO
#[case("[sqrt(0.000000000000000000001)]", "[√10/100000000000]")] // TODO
#[case("[sqrt(0.000000000000000000000001)]", "[1/1000000000000]")] // TODO
#[case("[sqrt(0.000000000000000000000000001)]", "[√10/100000000000000]")] // TODO
#[case("[sqrt(0.000000000000000000000000000001)]", "[1/1000000000000000]")] // TODO
fn sqrt_small_number(#[case] input: String, #[case] expected: String) {
    assert_eq!(expected, s(input.clone()), "简单表达式“{}”", input);
}

#[rstest]
#[case("[sqrt(2)]", "[√2]")]
#[case("[sqrt(4)]", "[2]")]
#[case("[sqrt(8)]", "[2√2]")]
fn sqrt_special(#[case] input: String, #[case] expected: String) {
    assert_eq!(expected, s(input.clone()), "简单表达式“{}”", input);
}

#[rstest]
#[case("[1/pi()]", "[1/π]")]
#[case("[1/e()]", "[1/e]")]
#[case("[pi()/1]", "[π]")]
#[case("[pi()/2]", "[π/2]")]
#[case("[pi()/3]", "[π/3]")]
#[case("[e()/1]", "[e]")]
#[case("[e()/2]", "[e/2]")]
#[case("[e()/3]", "[e/3]")]
fn frac_builtin_object(#[case] input: String, #[case] expected: String) {
    assert_eq!(expected, s(input.clone()), "简单表达式“{}”", input);
}

#[rstest]
#[case("[0/1]", "[0]")]
#[case("[0/-1]", "[0]")]
#[case("[-0/1]", "[0]")]
#[case("[-0/-1]", "[0]")]
#[case("[1/1]", "[1]")]
#[case("[1/-1]", "[-1]")]
#[case("[-1/1]", "[-1]")]
#[case("[-1/-1]", "[1]")]
fn frac_normal_number(#[case] input: String, #[case] expected: String) {
    assert_eq!(expected, s(input.clone()), "简单表达式“{}”", input);
}

#[rstest]
#[case("[1/10]", "[1/10]")]
#[case("[1/100]", "[1/100]")]
#[case("[1/1000]", "[1/1000]")]
#[case("[1/10000]", "[1/10000]")]
#[case("[1/100000]", "[1/100000]")]
#[case("[1/1000000]", "[1/1000000]")]
#[case("[1/10000000]", "[1/10000000]")]
#[case("[1/100000000]", "[1/100000000]")]
#[case("[1/1000000000]", "[1/1000000000]")]
#[case("[1/10000000000]", "[1/10000000000]")]
#[case("[1/100000000000]", "[1/100000000000]")]
#[case("[1/1000000000000]", "[1/1000000000000]")]
#[case("[1/1000000000000000]", "[1/1000000000000000]")]
#[case("[1/1000000000000000000]", "[1/1000000000000000000]")]
#[case("[1/1000000000000000000000]", "[1/1000000000000000000000]")]
#[case("[1/1000000000000000000000000]", "[1/1000000000000000000000000]")]
#[case("[1/1000000000000000000000000000]", "[1/1000000000000000000000000000]")]
#[case(
    "[1/1000000000000000000000000000000]",
    "[1/1000000000000000000000000000000]"
)]
#[case("[10/1]", "[10]")]
#[case("[100/1]", "[100]")]
#[case("[1000/1]", "[1000]")]
#[case("[10000/1]", "[10000]")]
#[case("[100000/1]", "[100000]")]
#[case("[1000000/1]", "[1000000]")]
#[case("[10000000/1]", "[10000000]")]
#[case("[100000000/1]", "[100000000]")]
#[case("[1000000000/1]", "[1000000000]")]
#[case("[10000000000/1]", "[10000000000]")]
#[case("[100000000000/1]", "[100000000000]")]
#[case("[1000000000000/1]", "[1000000000000]")]
#[case("[1000000000000000/1]", "[1000000000000000]")]
#[case("[1000000000000000000/1]", "[1000000000000000000]")]
#[case("[1000000000000000000000/1]", "[1000000000000000000000]")]
#[case("[1000000000000000000000000/1]", "[1000000000000000000000000]")]
#[case("[1000000000000000000000000000/1]", "[1000000000000000000000000000]")]
#[case(
    "[1000000000000000000000000000000/1]",
    "[1000000000000000000000000000000]"
)]
#[case("[10/2]", "[5]")]
#[case("[100/2]", "[50]")]
#[case("[1000/2]", "[500]")]
#[case("[10000/2]", "[5000]")]
#[case("[100000/2]", "[50000]")]
#[case("[1000000/2]", "[500000]")]
#[case("[10000000/2]", "[5000000]")]
#[case("[100000000/2]", "[50000000]")]
#[case("[1000000000/2]", "[500000000]")]
#[case("[10000000000/2]", "[5000000000]")]
#[case("[100000000000/2]", "[50000000000]")]
#[case("[1000000000000/2]", "[500000000000]")]
#[case("[1000000000000000/2]", "[500000000000000]")]
#[case("[1000000000000000000/2]", "[500000000000000000]")]
#[case("[1000000000000000000000/2]", "[500000000000000000000]")]
#[case("[1000000000000000000000000/2]", "[500000000000000000000000]")]
#[case("[1000000000000000000000000000/2]", "[500000000000000000000000000]")]
#[case(
    "[1000000000000000000000000000000/2]",
    "[500000000000000000000000000000]"
)]
#[case("[10/3]", "[10/3]")]
#[case("[100/3]", "[100/3]")]
#[case("[1000/3]", "[1000/3]")]
#[case("[10000/3]", "[10000/3]")]
#[case("[100000/3]", "[100000/3]")]
#[case("[1000000/3]", "[1000000/3]")]
#[case("[10000000/3]", "[10000000/3]")]
#[case("[100000000/3]", "[100000000/3]")]
#[case("[1000000000/3]", "[1000000000/3]")]
#[case("[10000000000/3]", "[10000000000/3]")]
#[case("[100000000000/3]", "[100000000000/3]")]
#[case("[1000000000000/3]", "[1000000000000/3]")]
#[case("[1000000000000000/3]", "[1000000000000000/3]")]
#[case("[1000000000000000000/3]", "[1000000000000000000/3]")]
#[case("[1000000000000000000000/3]", "[1000000000000000000000/3]")]
#[case("[1000000000000000000000000/3]", "[1000000000000000000000000/3]")]
#[case("[1000000000000000000000000000/3]", "[1000000000000000000000000000/3]")]
#[case(
    "[1000000000000000000000000000000/3]",
    "[1000000000000000000000000000000/3]"
)]
fn frac_big_number(#[case] input: String, #[case] expected: String) {
    assert_eq!(expected, s(input.clone()), "简单表达式“{}”", input);
}

#[rstest]
#[case("[1/0.1]", "[10]")]
#[case("[1/0.01]", "[100]")]
#[case("[1/0.001]", "[1000]")]
#[case("[1/0.0001]", "[10000]")]
#[case("[1/0.00001]", "[100000]")]
#[case("[1/0.000001]", "[1000000]")]
#[case("[1/0.0000001]", "[10000000]")]
#[case("[1/0.00000001]", "[100000000]")]
#[case("[1/0.000000001]", "[1000000000]")]
#[case("[1/0.0000000001]", "[10000000000]")]
#[case("[1/0.00000000001]", "[100000000000]")]
#[case("[1/0.000000000001]", "[1000000000000]")]
#[case("[1/0.000000000000001]", "[1000000000000000]")]
#[case("[1/0.000000000000000001]", "[1000000000000000000]")]
#[case("[1/0.000000000000000000001]", "[1000000000000000000000]")]
#[case("[1/0.000000000000000000000001]", "[1000000000000000000000000]")]
#[case("[1/0.000000000000000000000000001]", "[1000000000000000000000000000]")]
#[case(
    "[1/0.000000000000000000000000000001]",
    "[1000000000000000000000000000000]"
)]
#[case("[0.1/1]", "[1/10]")]
#[case("[0.01/1]", "[1/100]")]
#[case("[0.001/1]", "[1/1000]")]
#[case("[0.0001/1]", "[1/10000]")]
#[case("[0.00001/1]", "[1/100000]")]
#[case("[0.000001/1]", "[1/1000000]")]
#[case("[0.0000001/1]", "[1/10000000]")]
#[case("[0.00000001/1]", "[1/100000000]")]
#[case("[0.000000001/1]", "[1/1000000000]")]
#[case("[0.0000000001/1]", "[1/10000000000]")]
#[case("[0.00000000001/1]", "[1/100000000000]")]
#[case("[0.000000000001/1]", "[1/1000000000000]")]
#[case("[0.000000000000001/1]", "[1/1000000000000000]")]
#[case("[0.000000000000000001/1]", "[1/1000000000000000000]")]
#[case("[0.000000000000000000001/1]", "[1/1000000000000000000000]")]
#[case("[0.000000000000000000000001/1]", "[1/1000000000000000000000000]")]
#[case(
    "[0.000000000000000000000000001/1]",
    "[1/1000000000000000000000000000]"
)]
#[case(
    "[0.000000000000000000000000000001/1]",
    "[1/1000000000000000000000000000000]"
)]
#[case("[0.1/2]", "[1/20]")]
#[case("[0.01/2]", "[1/200]")]
#[case("[0.001/2]", "[1/2000]")]
#[case("[0.0001/2]", "[1/20000]")]
#[case("[0.00001/2]", "[1/200000]")]
#[case("[0.000001/2]", "[1/2000000]")]
#[case("[0.0000001/2]", "[1/20000000]")]
#[case("[0.00000001/2]", "[1/200000000]")]
#[case("[0.000000001/2]", "[1/2000000000]")]
#[case("[0.0000000001/2]", "[1/20000000000]")]
#[case("[0.00000000001/2]", "[1/200000000000]")]
#[case("[0.000000000001/2]", "[1/2000000000000]")]
#[case("[0.000000000000001/2]", "[1/2000000000000000]")]
#[case("[0.000000000000000001/2]", "[1/2000000000000000000]")]
#[case("[0.000000000000000000001/2]", "[1/2000000000000000000000]")]
#[case("[0.000000000000000000000001/2]", "[1/2000000000000000000000000]")]
#[case(
    "[0.000000000000000000000000001/2]",
    "[1/2000000000000000000000000000]"
)]
#[case(
    "[0.000000000000000000000000000001/2]",
    "[1/2000000000000000000000000000000]"
)]
fn frac_small_number(#[case] input: String, #[case] expected: String) {
    assert_eq!(expected, s(input.clone()), "简单表达式“{}”", input);
}

#[rstest]
#[case("[1/sqrt(pi())]", "[√π/π]")] // TODO
#[case("[1/sqrt(e())]", "[√e/e]")] // TODO
#[case("[sqrt(pi())/1]", "[√π]")]
#[case("[sqrt(e())/1]", "[√e]")]
#[case("[sqrt(pi())/2]", "[√π/2]")] // TODO
#[case("[sqrt(e())/2]", "[√e/2]")] // TODO
#[case("[sqrt(pi())/3]", "[√π/3]")] // TODO
#[case("[sqrt(e())/3]", "[√e/3]")] // TODO 
fn frac_sqrt_builtin_object(#[case] input: String, #[case] expected: String) {
    assert_eq!(expected, s(input.clone()), "简单表达式“{}”", input);
}

#[rstest]
#[case("[1/sqrt(10)]", "[√10/10]")] // TODO
#[case("[1/sqrt(100)]", "[1/10]")] // TODO
#[case("[1/sqrt(1000)]", "[√10/100]")] // TODO
#[case("[1/sqrt(10000)]", "[1/100]")] // TODO
#[case("[1/sqrt(100000)]", "[√10/1000]")] // TODO
#[case("[1/sqrt(1000000)]", "[1/1000]")] // TODO
#[case("[1/sqrt(10000000)]", "[√10/10000]")] // TODO
#[case("[1/sqrt(100000000)]", "[1/10000]")] // TODO
#[case("[1/sqrt(1000000000)]", "[√10/100000]")] // TODO
#[case("[1/sqrt(10000000000)]", "[1/100000]")] // TODO
#[case("[1/sqrt(100000000000)]", "[√10/1000000]")] // TODO
#[case("[1/sqrt(1000000000000)]", "[1/1000000]")] // TODO
#[case("[1/sqrt(1000000000000000)]", "[√10/100000000]")] // TODO
#[case("[1/sqrt(1000000000000000000)]", "[1/1000000000]")] // TODO
#[case("[1/sqrt(1000000000000000000000)]", "[√10/100000000000]")] // TODO
#[case("[1/sqrt(1000000000000000000000000)]", "[1/1000000000000]")] // TODO
#[case("[1/sqrt(1000000000000000000000000000)]", "[√10/100000000000000]")] // TODO
#[case("[1/sqrt(1000000000000000000000000000000)]", "[1/1000000000000000]")] // TODO
#[case("[sqrt(10)/1]", "[√10]")]
#[case("[sqrt(100)/1]", "[10]")]
#[case("[sqrt(1000)/1]", "[10√10]")]
#[case("[sqrt(10000)/1]", "[100]")]
#[case("[sqrt(100000)/1]", "[100√10]")]
#[case("[sqrt(1000000)/1]", "[1000]")]
#[case("[sqrt(10000000)/1]", "[1000√10]")]
#[case("[sqrt(100000000)/1]", "[10000]")]
#[case("[sqrt(1000000000)/1]", "[10000√10]")]
#[case("[sqrt(10000000000)/1]", "[100000]")]
#[case("[sqrt(100000000000)/1]", "[100000√10]")]
#[case("[sqrt(1000000000000)/1]", "[1000000]")]
#[case("[sqrt(1000000000000000)/1]", "[10000000√10]")]
#[case("[sqrt(1000000000000000000)/1]", "[1000000000]")]
#[case("[sqrt(1000000000000000000000)/1]", "[10000000000√10]")]
#[case("[sqrt(1000000000000000000000000)/1]", "[1000000000000]")]
#[case("[sqrt(1000000000000000000000000000)/1]", "[10000000000000√10]")]
#[case("[sqrt(1000000000000000000000000000000)/1]", "[1000000000000000]")]
#[case("[sqrt(10)/2]", "[√10/2]")] // TODO
#[case("[sqrt(100)/2]", "[5]")]
#[case("[sqrt(1000)/2]", "[5√10]")]
#[case("[sqrt(10000)/2]", "[50]")]
#[case("[sqrt(100000)/2]", "[50√10]")]
#[case("[sqrt(1000000)/2]", "[500]")]
#[case("[sqrt(10000000)/2]", "[500√10]")]
#[case("[sqrt(100000000)/2]", "[5000]")]
#[case("[sqrt(1000000000)/2]", "[5000√10]")]
#[case("[sqrt(10000000000)/2]", "[50000]")]
#[case("[sqrt(100000000000)/2]", "[50000√10]")]
#[case("[sqrt(1000000000000)/2]", "[500000]")]
#[case("[sqrt(1000000000000000)/2]", "[5000000√10]")]
#[case("[sqrt(1000000000000000000)/2]", "[500000000]")]
#[case("[sqrt(1000000000000000000000)/2]", "[5000000000√10]")]
#[case("[sqrt(1000000000000000000000000)/2]", "[500000000000]")]
#[case("[sqrt(1000000000000000000000000000)/2]", "[5000000000000√10]")]
#[case("[sqrt(1000000000000000000000000000000)/2]", "[500000000000000]")]
#[case("[sqrt(10)/3]", "[√10/3]")] // TODO
#[case("[sqrt(100)/3]", "[10/3]")] // TODO
#[case("[sqrt(1000)/3]", "[10√10/3]")] // TODO
#[case("[sqrt(10000)/3]", "[100/3]")] // TODO
#[case("[sqrt(100000)/3]", "[100√10/3]")] // TODO
#[case("[sqrt(1000000)/3]", "[1000/3]")] // TODO
#[case("[sqrt(10000000)/3]", "[1000√10/3]")] // TODO
#[case("[sqrt(100000000)/3]", "[10000/3]")] // TODO
#[case("[sqrt(1000000000)/3]", "[10000√10/3]")] // TODO
#[case("[sqrt(10000000000)/3]", "[100000/3]")] // TODO
#[case("[sqrt(100000000000)/3]", "[100000√10/3]")] // TODO
#[case("[sqrt(1000000000000)/3]", "[1000000/3]")] // TODO
#[case("[sqrt(1000000000000000)/3]", "[10000000√10/3]")] // TODO
#[case("[sqrt(1000000000000000000)/3]", "[1000000000/3]")] // TODO
#[case("[sqrt(1000000000000000000000)/3]", "[10000000000√10/3]")] // TODO
#[case("[sqrt(1000000000000000000000000)/3]", "[1000000000000/3]")] // TODO
#[case("[sqrt(1000000000000000000000000000)/3]", "[10000000000000√10/3]")] // TODO
#[case("[sqrt(1000000000000000000000000000000)/3]", "[1000000000000000/3]")] // TODO
fn frac_sqrt_big_number(#[case] input: String, #[case] expected: String) {
    assert_eq!(expected, s(input.clone()), "简单表达式“{}”", input);
}

#[rstest]
#[case("[1/sqrt(0.1)]", "[√10]")] // TODO
#[case("[1/sqrt(0.01)]", "[10]")] // TODO
#[case("[1/sqrt(0.001)]", "[10√10]")] // TODO
#[case("[1/sqrt(0.0001)]", "[100]")] // TODO
#[case("[1/sqrt(0.00001)]", "[100√10]")] // TODO
#[case("[1/sqrt(0.000001)]", "[1000]")] // TODO
#[case("[1/sqrt(0.0000001)]", "[1000√10]")] // TODO
#[case("[1/sqrt(0.00000001)]", "[10000]")] // TODO
#[case("[1/sqrt(0.000000001)]", "[10000√10]")] // TODO
#[case("[1/sqrt(0.0000000001)]", "[100000]")] // TODO
#[case("[1/sqrt(0.00000000001)]", "[100000√10]")] // TODO
#[case("[1/sqrt(0.000000000001)]", "[1000000]")] // TODO
#[case("[1/sqrt(0.000000000000001)]", "[10000000√10]")] // TODO
#[case("[1/sqrt(0.000000000000000001)]", "[1000000000]")] // TODO
#[case("[1/sqrt(0.000000000000000000001)]", "[10000000000√10]")] // TODO
#[case("[1/sqrt(0.000000000000000000000001)]", "[1000000000000]")] // TODO
#[case("[1/sqrt(0.000000000000000000000000001)]", "[10000000000000√10]")] // TODO
#[case("[1/sqrt(0.000000000000000000000000000001)]", "[1000000000000000]")] // TODO
#[case("[sqrt(0.1)/1]", "[√10/10]")] // TODO
#[case("[sqrt(0.01)/1]", "[1/10]")] // TODO
#[case("[sqrt(0.001)/1]", "[√10/100]")] // TODO
#[case("[sqrt(0.0001)/1]", "[1/100]")] // TODO
#[case("[sqrt(0.00001)/1]", "[√10/1000]")] // TODO
#[case("[sqrt(0.000001)/1]", "[1/1000]")] // TODO
#[case("[sqrt(0.0000001)/1]", "[√10/10000]")] // TODO
#[case("[sqrt(0.00000001)/1]", "[1/10000]")] // TODO
#[case("[sqrt(0.000000001)/1]", "[√10/100000]")] // TODO
#[case("[sqrt(0.0000000001)/1]", "[1/100000]")] // TODO
#[case("[sqrt(0.00000000001)/1]", "[√10/1000000]")] // TODO
#[case("[sqrt(0.000000000001)/1]", "[1/1000000]")] // TODO
#[case("[sqrt(0.000000000000001)/1]", "[√10/100000000]")] // TODO
#[case("[sqrt(0.000000000000000001)/1]", "[1/1000000000]")] // TODO
#[case("[sqrt(0.000000000000000000001)/1]", "[√10/100000000000]")] // TODO
#[case("[sqrt(0.000000000000000000000001)/1]", "[1/1000000000000]")] // TODO
#[case("[sqrt(0.000000000000000000000000001)/1]", "[√10/100000000000000]")] // TODO
#[case("[sqrt(0.000000000000000000000000000001)/1]", "[1/1000000000000000]")] // TODO
#[case("[sqrt(0.1)/2]", "[√10/20]")] // TODO
#[case("[sqrt(0.01)/2]", "[1/20]")] // TODO
#[case("[sqrt(0.001)/2]", "[√10/200]")] // TODO
#[case("[sqrt(0.0001)/2]", "[1/200]")] // TODO
#[case("[sqrt(0.00001)/2]", "[√10/2000]")] // TODO
#[case("[sqrt(0.000001)/2]", "[1/2000]")] // TODO
#[case("[sqrt(0.0000001)/2]", "[√10/20000]")] // TODO
#[case("[sqrt(0.00000001)/2]", "[1/20000]")] // TODO
#[case("[sqrt(0.000000001)/2]", "[√10/200000]")] // TODO
#[case("[sqrt(0.0000000001)/2]", "[1/200000]")] // TODO
#[case("[sqrt(0.00000000001)/2]", "[√10/2000000]")] // TODO
#[case("[sqrt(0.000000000001)/2]", "[1/2000000]")] // TODO
#[case("[sqrt(0.000000000000001)/2]", "[√10/200000000]")] // TODO
#[case("[sqrt(0.000000000000000001)/2]", "[1/2000000000]")] // TODO
#[case("[sqrt(0.000000000000000000001)/2]", "[√10/200000000000]")] // TODO
#[case("[sqrt(0.000000000000000000000001)/2]", "[1/2000000000000]")] // TODO
#[case("[sqrt(0.000000000000000000000000001)/2]", "[√10/200000000000000]")] // TODO
#[case("[sqrt(0.000000000000000000000000000001)/2]", "[1/2000000000000000]")] // TODO
#[case("[sqrt(0.1)/3]", "[√10/30]")] // TODO
#[case("[sqrt(0.01)/3]", "[1/30]")] // TODO
#[case("[sqrt(0.001)/3]", "[√10/300]")] // TODO
#[case("[sqrt(0.0001)/3]", "[1/300]")] // TODO
#[case("[sqrt(0.00001)/3]", "[√10/3000]")] // TODO
#[case("[sqrt(0.000001)/3]", "[1/3000]")] // TODO
#[case("[sqrt(0.0000001)/3]", "[√10/30000]")] // TODO
#[case("[sqrt(0.00000001)/3]", "[1/30000]")] // TODO
#[case("[sqrt(0.000000001)/3]", "[√10/300000]")] // TODO
#[case("[sqrt(0.0000000001)/3]", "[1/300000]")] // TODO
#[case("[sqrt(0.00000000001)/3]", "[√10/3000000]")] // TODO
#[case("[sqrt(0.000000000001)/3]", "[1/3000000]")] // TODO
#[case("[sqrt(0.000000000000001)/3]", "[√10/300000000]")] // TODO
#[case("[sqrt(0.000000000000000001)/3]", "[1/3000000000]")] // TODO
#[case("[sqrt(0.000000000000000000001)/3]", "[√10/300000000000]")] // TODO
#[case("[sqrt(0.000000000000000000000001)/3]", "[1/3000000000000]")] // TODO
#[case("[sqrt(0.000000000000000000000000001)/3]", "[√10/300000000000000]")] // TODO
#[case("[sqrt(0.000000000000000000000000000001)/3]", "[1/3000000000000000]")] // TODO
fn frac_sqrt_small_number(#[case] input: String, #[case] expected: String) {
    assert_eq!(expected, s(input.clone()), "简单表达式“{}”", input);
}

#[rstest]
#[case("[1/sqrt(2)]", "[√2/2]")] // TODO
#[case("[1/sqrt(4)]", "[1/2]")] // TODO
#[case("[1/sqrt(8)]", "[√2/4]")] // TODO
#[case("[sqrt(2)/1]", "[√2]")]
#[case("[sqrt(4)/1]", "[2]")]
#[case("[sqrt(8)/1]", "[2√2]")]
#[case("[sqrt(2)/2]", "[√2/2]")] // TODO
#[case("[sqrt(4)/2]", "[1]")]
#[case("[sqrt(8)/2]", "[√2]")]
#[case("[sqrt(2)/3]", "[√2/3]")] // TODO
#[case("[sqrt(4)/3]", "[2/3]")] // TODO
#[case("[sqrt(8)/3]", "[2√2/3]")] // TODO TODO
fn frac_sqrt_special(#[case] input: String, #[case] expected: String) {
    assert_eq!(expected, s(input.clone()), "简单表达式“{}”", input);
}

#[rstest]
#[case("[2/10]", "[1/5]")]
#[case("[10/2]", "[5]")]
fn frac_special(#[case] input: String, #[case] expected: String) {
    assert_eq!(expected, s(input.clone()), "简单表达式“{}”", input);
}

#[rstest]
#[case("[]", "[]")]
#[case("[1, 2]", "[1, 2]")]
#[case("[1, 2,  3]", "[1, 2, 3]")]
fn special(#[case] input: String, #[case] expected: String) {
    assert_eq!(expected, s(input.clone()), "简单表达式“{}”", input);
}
